\section{Ejercicio 3 (Programacion dinamica):}
La programación dinamica es otra tecnica algoritmica, consiste en resolver los subproblemas de tamaños menores y dados estos resultados, generar la solución al problema original, pero la tecnica aprovecha estructuras de datos(generalmente matrices) para guardar los subproblemas que ya calculamos, y si en algun momento lo tenemos que calcular de nuevo(por ejemplo si dos subproblemas del mismo tamaño necesitan del mismo subproblema de tamaño mas chico) nos ahorramos el calculo porque tenemos en la estructura con la respuesta.


Principio de optimalidad de Bellman:
Un problema satisface el principio si una subsolucion optima debe ser solucion del subproblema asociado a esa subsolucion. En este problema podriamos decir que para una secuencia de largo n un subproblema sea la subsecuencia de 0 a n - 1, y si tenemos esta subsolucion, entonces, la solucion al problema original va a ser menor o igual a esta subsolucion, de hecho va a ser igual o la misma menos uno(siempre y cuando no sea 0). Probemos esto que acabamos de decir, supongamos que tenemos una subsolucion que vale $x \geq 2$ para el subproblema de tamaño igual menos uno a la del problema que tenemos que resolver, y tambien supongamos que la solucion al problema es un $x'$ tal que $x' = x - 2$, si pasa esto podriamos quedarnos con esa combinacion de colores(con la que nos da $x'$) sacarle el ultimo numero y tendriamos una nueva respuesta $x''$ tal que $x'' = x'-1$ ya que solamente sacamos el ultimo numero, pero entonces $x'' < x$ osea que $x$ no era optima, por ende entramos en un absurdo. Que esto lo supusimos al decir que habia una solucion mucho mejor que la de la solucion. Osea que de una subsolucion no podemos empeorar la solucion o solo la empeoramos en una unidad, la dejamos igual cuando el nuevo numero lo podemos pintar desde alguna de la combinaciones optimas anteriores, o empeora en uno si no existe combinacion optima anterior desde la cual no podamos pintar este numero de rojo o de azul(notar que ahora hay combinaciones que por ahi no son optimas para el subproblema anterior pero se diferencian en uno). Gracias a esto cumple el principio de optimalidad de Bellman, pero notemos que si el problema fuese dar las subsecuencias rojas y azules, no se cumpliria el principio ya que, por lo ultimo que dijimos, cuando no hay una combinacion optima anterior puede ser que las nuevas soluciones no esten asociadas a las del subproblema, entonces no cumpliria el principio.

Como vimos en backtracking al pintar un numero, solo nos importa cuales fueron el ultimo rojo y el ultimo azul que se pintaron, entonces al agregar un nuevo a la secuencia, tenemos que buscar la combinacion de ultimo rojo y ultimo azul optima tal que nos deje pintar este ultimo numero o buscar una combinacion de rojo y azul la cual no pintemos este ultimo pero sea mejor que si lo pintaramos. Entonces por problema tenemos que buscar cual es la combinacion de ultimo rojo y ultimo azul que nos haga optima la solucion.

El algoritmo dado se va a basar en eso, va a terminar calculando todas las combinaciones de ultimo rojo y ultimo azul para ver cual es la optima. Como calculamos cada una de estas combinaciones? recientemente dijimos que para pintar un numero de forma optima teniamos que buscar en la combinacion de ultimo rojo ultimo azul valida que sea optima. Entonces si queremos pintar el ultimo indice de rojo, sea $r$, y como ultimo azul un indice $a$ con $0 \leq a < r$, deberiamos buscar el $r'$ tal que sea optimo y que $secuencia_{r'} < secuencia_r$, para esto vamos a tener que recorrer de $0$ a $r-1$ buscando el que cumpla estas condiciones.
Otro tema importante de la programacion dinamica es como guardamos los datos, una manera es tener una matriz de 2 dimensiones, en el que el indice de la fila representa el indice del ultimo azul y el indice de la columnas el del rojo, osea que sea $M$ la matriz, $M_{r,b}$ nos da cual la subsolucion para esa combinacion de rojo y azul. Un caso que deje afuera pero hay que tener en cuenta es que hay una combinacion que es en la que no se pinta ninguno de rojo o de azul, o no se pinta ninguno, este indice se va a representar en la ultima fila y en la ultima columna, resumiendo para un problema de $n$ numeros vamos a tener una matriz $M$ de ($n+1 x n+1$) donde la la fila n+1 y la columna n+1 representan cuando el ultimo azul o ultimo rojo respectivamente son nulos.

Este es nuestro algoritmo, calculamos la matriz y buscamos en ella cual es el optimo, ahora tenemos que decidir en que orden calculamos los datos, ya que como para calcular $M_{r,b}$ tenemos que tener calculado $M_{i,b}$ con $i<r$ y $M_{r+1,b}$ va a necesitar de estos tambien, podemos ir de una manera constructiva, empezando en los casos bases, que son los cuando pintamos nada mas el primero de un color(que sabemos que va a dejar a todos los otros numeros siguientes sin pintar entonces la subsolucion es n - 1) y si no pintamos ninguno(osea quedan n sin pintar), esto era el indice 0, despues pasamos para el indice 1 y calculamos todas las combinaciones nuevas, osea ya teniamos calculado $M_{0,n+1}$ y $M_{n+1,0}$ y $M_{n+1,n+1}$, y ahora calculamos $M_{1,0}$, $M_{1,n+1}$, $M_{0,1}$, $M_{n+1, 1}$ (notar que $M_{r,b}$ con $r = b$ es invalido porque no podemos pintar un mismo numero de dos colores). Una vez calculada toda la matriz buscamos el optimo dentro de esta y esa es nuestra solucion.


\begin{algorithm}[H]
\NoCaptionOfAlgo
	\KwData{	
	arreglo = el arreglo de numeros entero\\
	n = el tamaño del arreglo\\
	\KwResult{La cantidad minima de numeros sin pintar para una secuencia de numeros de largo n}
	\caption{\algoritmo{ej3}{int arreglo[], n}{int}}
		\tcc{Creamos nuestra matriz}
		int m[n+1][n+1]\\ \\

		\tcc{Le guardamos los triviales, los del primer indice(0)}
		int m[0][n] = n - 1\\
		int m[n][0] = n - 1\\
		int m[n][n] = n \\ \\
		res $\leftarrow$ BT(0, arreglo, n, NULL, NULL, n, 0)\\

		\tcc{Ahora recorremos todos los indices}
		\For(){$i \leftarrow 1$ \KwTo n}{
			\tcc{Y para cada indice, calculamos el optimo si pintaramos este de azul o de rojo y las combinaciones del otro}
			\For(){$j \leftarrow o$ \KwTo i - 1}{
				m[i][j] $\leftarrow$ buscarOptimoPintandoDeRojo(i, j, arreglo, m, n) \\
				m[j][i] $\leftarrow$ buscarOptimoPintandoDeAzul(i, j, arreglo, m, n)
			}
			\\
			\tcc{En esa iteracion dejamos de lado la combinacion si pintamos este ultimo de azul y no pintamos ninguno de rojo, y viceversa}
			m[i][n] $\leftarrow$ buscarOptimoPintandoDeRojo(i, n, arreglo, m, n) \\
			m[n][i] $\leftarrow$ buscarOptimoPintandoDeAzul(i, n, arreglo, m, n)
		}

		\tcc{Una vez ya calculada la matriz buscamos el menor, min es una funcion que busca el menor de una matriz en $O(m)$ donde m es la cantidad de elementos que hay en la matriz}
		res $\leftarrow$ min(m)
	}
\end{algorithm}

\begin{algorithm}[H]
\NoCaptionOfAlgo
	\KwData{	
	r = El indice que estamos pintando de rojo\\
	a = El indice que fijamos de azul\\
	arreglo = La secuencia de numeros \\
	m = La matriz(pasa por referencia)\\
	n = el tamaño del arreglo\\
	\KwResult{La cantidad minima de numeros sin pintar si elejimos como ultimo pintado de rojo al indice r y de azul a a}
	\caption{\algoritmo{buscarOptimoPintandoDeRojo}{int r, a, arreglo[], m, n}{int}}
		\tcc{Ponemos como optimo momentaneo al $M_{n, a}$ osea si el primer rojo que pintamos sea este numero, total siempre es una solucion valida}
		int optimoActual $\leftarrow$ m[n][a]\\
		\tcc{Recorremos con el azul fijado, que pasaria si partieramos desde los anteriores rojos}
		\For(){$ri \leftarrow 0$ \KwTo r - 1}{
			\tcc{Nos fijamos si el numero de la secuencia de ri es menor al de r,(osea si podemos pintarlo a partir de ri), y si es mas chico que el optimoActual}
			\If{ri != a \textbf{and} arreglo[ri] $<$ arreglo[r] \textbf{and} m[ri][a] $<$ optimoActual}{
				\tcc{Si es menor, marcamos a este como el optimoActual}
				optimoActual $\leftarrow$ m[ri][a]
			}
		}
		\tcc{Retornamos el optimo del cual podemos pintar y como pintamos este ultimo se reduce en 1}
		res $\leftarrow$ optimoActual - 1 
	}
\end{algorithm}

\begin{algorithm}[H]
\NoCaptionOfAlgo
	\KwData{	
	a = El indice que estamos pintando de azul\\
	r = El indice que fijamos de rojo\\
	\caption{\algoritmo{buscarOptimoPintandoDeRojo}{int a, j, arreglo[], m, n}{int}}
		\tcc{El codigo de esta funcion es totalmente analogo al de rojo}
		int optimoActual $\leftarrow$ m[r][n]\\
		\For(){$ai \leftarrow 0$ \KwTo a - 1}{
			\If{ai != r \textbf{and} arreglo[ai] $>$ arreglo[a] \textbf{and} m[r][ai] $<$ optimoActual}{
				optimoActual $\leftarrow$ m[r][ai]
			}
		}
		res $\leftarrow$ optimoActual - 1 
	}
\end{algorithm}