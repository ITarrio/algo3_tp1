#include <iostream>
#include <array>
#include <vector>



int backtrack(int i, int arreglo[], int n, int ultimoAzul, int ultimoRojo, bool hayAzul, bool hayRojo ) {
    if (i == n - 1) {
        if (!hayRojo || arreglo[i] > ultimoRojo || !hayAzul || arreglo[i] < ultimoAzul){
            return 0;
        } else {;
            return 1;
        }
    }else{
        int minSiRojo = n, minSiAzul = n, minSinPintar;
        if (!hayRojo || arreglo[i] > ultimoRojo){ // Pintamos de rojo solo si el numero es mas grande que el ultimo rojo pintado
            minSiRojo = backtrack(i + 1, arreglo, n, ultimoAzul, arreglo[i], hayAzul, true); // Aca obtenemos la cantidad minima de numero sin pintar si pintamos este num de rojo
        }

        if (!hayAzul || arreglo[i] < ultimoAzul){ // Igual que para el rojo ahora lo hacemos para el azul
            minSiAzul = backtrack(i + 1, arreglo, n, arreglo[i], ultimoRojo, true, hayRojo);
        }

        minSinPintar = backtrack(i + 1, arreglo, n, ultimoAzul, ultimoRojo, hayAzul, hayRojo) + 1;// Ahora probamos sin pintarlo, le sumamos uno porque este numero no lo pintamos

        if (minSiRojo <= minSiAzul && minSiRojo <= minSinPintar) {
            return minSiRojo;
        } else {
            if (minSiAzul <= minSinPintar) {
                return minSiAzul;
            } else {
                return minSinPintar;
            }
        }
    }
}

int backtrackImproved(int i, int arreglo[], int n, int ultimoAzul, int ultimoRojo, bool hayAzul, bool hayRojo, int sinPintar )
{
    if (i == n - 1) {
        if (!hayRojo || arreglo[i] > ultimoRojo || !hayAzul || arreglo[i] < ultimoAzul){
            return 0;
        } else {;
            return 1;
        }
    }else{
        int minSiRojo = n, minSiAzul = n, minSinPintar;
        if (!hayRojo || arreglo[i] > ultimoRojo){ // Pintamos de rojo solo si el numero es mas grande que el ultimo rojo pintado
            minSiRojo = backtrackImproved(i + 1, arreglo, n, ultimoAzul, arreglo[i], hayAzul, true, sinPintar); // Aca obtenemos la cantidad minima de numero sin pintar si pintamos este num de rojo
            if (minSiRojo == sinPintar) {
                return minSiRojo;
            }
        }


        if (!hayAzul || arreglo[i] < ultimoAzul){ // Igual que para el rojo ahora lo hacemos para el azul
            minSiAzul = backtrackImproved(i + 1, arreglo, n, arreglo[i], ultimoRojo, true, hayRojo, sinPintar);
            if (minSiAzul == sinPintar) {
                return minSiAzul;
            }
        }

        minSinPintar = backtrackImproved(i + 1, arreglo, n, ultimoAzul, ultimoRojo, hayAzul, hayRojo, sinPintar + 1) + 1;// Ahora probamos sin pintarlo, le sumamos uno porque este numero no lo pintamos

        if (minSiRojo <= minSiAzul && minSiRojo <= minSinPintar) {
            return minSiRojo;
        } else {
            if (minSiAzul <= minSinPintar) {
                return minSiAzul;
            } else {
                return minSinPintar;
            }
        }
    }
}

int ej1(int arreglo[], int n){
    return backtrack(0, arreglo, n, NULL, NULL, false, false);
}

int ej2(int arreglo[], int n) {
    return backtrackImproved(0, arreglo, n, NULL, NULL, false, false, n);
}


struct dato {
    int sinPintar;
    int indice;
};

dato calcular(int indiceActual, dato anterior){
    int sinPintar = anterior.sinPintar + (indiceActual - anterior.indice - 1);
    return {sinPintar, indiceActual};
}

int cantidadSinPintar(int largo, dato dato) {
    return dato.sinPintar + (largo - 1 - dato.indice);
}

int ej3(int a[], int n){
    int menor[n], menor2[n], mayor[n], mayor2[n];
    for (int i = 0; i < n; i++) {
        mayor[i] = n;
        menor[i] = n;
        mayor2[i] = n;
        menor2[i] = n;
        for (int j = 0; j < i; j++) {
            if (a[i] < a[j]) {
                mayor2[i] = mayor[i];
                mayor[i] = j;
            }
            if (a[i] > a[j]) {
                menor2[i] = menor[i];
                menor[i] = j;
            }
        }
    }

    dato m[n+1][n+1];

    //Para el primer indice ya sabemos que pasa
    m[0][n] = {0, 0};
    m[n][0] = {0, 0};

    m[n][n] = {1, 0};

    for (int i = 1; i < n; i++) {
        int ant;
        for(int j = 0; j < i; j++) {

            //Rojo:
            ant = (menor[i] == j) ? menor2[i] : menor[i];
            m[i][j] = calcular(i, m[ant][j]);

            //Azul:
            ant = (mayor[i] == j) ? mayor2[i] : mayor[i];
            m[j][i] = calcular(i, m[j][ant]);
        }
        //Rojo:
        m[i][n] = calcular(i, m[menor[i]][n]);
        //Azul:
        m[n][i] = calcular(i, m[n][mayor[i]]);
    }

    //buscamos el optimo
    int optimo = n;
    for (int i = 0; i <= n; i++) {
        for(int j = 0; j <= n; j++) {
            if ((j != i || i == n) && cantidadSinPintar(n, m[i][j]) < optimo)  {
                optimo = cantidadSinPintar(n, m[i][j]);
            }

            if (j != i || i == n) {
                std::cout << m[j][i].sinPintar << ",";
            }else{
                std::cout << "X"<< ",";
            }
        }
        std::cout << std::endl;
    }
    return optimo;
}

int main() {
    int arreglo[] = {3, 11, 0, 1, 3, 5, 2, 4 , 1, 0, 9, 3};
    std::cout << ej1(arreglo, 12) << std::endl;
    std::cout << ej2(arreglo, 12) << std::endl;
    std::cout << ej3(arreglo, 12) << std::endl;

    return 0;
}

